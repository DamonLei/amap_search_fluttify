//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

#import "SubHandler12.h"

// Dart端一次方法调用所存在的栈, 只有当MethodChannel传递参数受限时, 再启用这个容器
extern NSMutableDictionary<NSString*, NSObject*>* STACK;
// Dart端随机存取对象的容器
extern NSMutableDictionary<NSNumber*, NSObject*>* HEAP;
// 日志打印开关
extern BOOL enableLog;

@implementation AmapSearchFluttifyPlugin (SubHandler12)
- (NSDictionary<NSString*, Handler>*) getSubHandler12 {
    return @{
        @"ObjectFactory::create_batchAMapBusStop": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapBusStop* ref = [[AMapBusStop alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapBusLine": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapBusLine* ref = [[AMapBusLine alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapDistrict": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapDistrict* ref = [[AMapDistrict alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTMC": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTMC* ref = [[AMapTMC alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapStep": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapStep* ref = [[AMapStep alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapPath": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapPath* ref = [[AMapPath alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapFutureTimeInfoElement": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapFutureTimeInfoElement* ref = [[AMapFutureTimeInfoElement alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapFutureTimeInfo": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapFutureTimeInfo* ref = [[AMapFutureTimeInfo alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapWalking": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapWalking* ref = [[AMapWalking alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTaxi": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTaxi* ref = [[AMapTaxi alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapRailwayStation": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapRailwayStation* ref = [[AMapRailwayStation alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapRailwaySpace": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapRailwaySpace* ref = [[AMapRailwaySpace alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapRailway": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapRailway* ref = [[AMapRailway alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapSegment": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapSegment* ref = [[AMapSegment alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTransit": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTransit* ref = [[AMapTransit alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapRoute": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapRoute* ref = [[AMapRoute alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapDistanceResult": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapDistanceResult* ref = [[AMapDistanceResult alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapLocalWeatherLive": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapLocalWeatherLive* ref = [[AMapLocalWeatherLive alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapLocalDayWeatherForecast": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapLocalDayWeatherForecast* ref = [[AMapLocalDayWeatherForecast alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapLocalWeatherForecast": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapLocalWeatherForecast* ref = [[AMapLocalWeatherForecast alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapNearbyUserInfo": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapNearbyUserInfo* ref = [[AMapNearbyUserInfo alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTrafficEvaluation": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTrafficEvaluation* ref = [[AMapTrafficEvaluation alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTrafficRoad": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTrafficRoad* ref = [[AMapTrafficRoad alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapTrafficInfo": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapTrafficInfo* ref = [[AMapTrafficInfo alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapCloudImage": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapCloudImage* ref = [[AMapCloudImage alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapCloudPOI": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapCloudPOI* ref = [[AMapCloudPOI alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapNearbyUploadInfo": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapNearbyUploadInfo* ref = [[AMapNearbyUploadInfo alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
        @"ObjectFactory::create_batchAMapSearchAPI": ^(NSObject <FlutterPluginRegistrar> * registrar, id argsBatch, FlutterResult methodResult) {
            NSMutableArray<NSNumber*>* resultList = [NSMutableArray array];
        
            for (int i = 0; i < [(NSNumber*) ((NSDictionary<NSString*, NSObject*>*) argsBatch)[@"length"] integerValue]; i++) {
                AMapSearchAPI* ref = [[AMapSearchAPI alloc] init];
                HEAP[@(ref.hash)] = ref;
        
                [resultList addObject:@(ref.hash)];
            }
        
            methodResult(resultList);
        
            if (enableLog) NSLog(@"HEAP: %@", HEAP);
        },
        
    };
}

@end
